"""This module provides a class to draw objects given a Cairo.Context and the
viewport's resolution.

Classes
-------
    ObjectPainter

"""
import numpy as np
from scipy import special

from .models.curve import CurveType
from util.clipping import clip_line


def init_forward_differences(shifts: 'list') -> 'list':
    """Initialize the first n forward differences where n is the number of
    shifts provided as input.

    Notes
    -----
        The initial forward differences are calculated using the reccurence
        relation:

            D^(k)[fn] = sum from t=0 to k of binom(k,t)*(-1)^t*fn+k-t

    References
    --------
        https://en.wikipedia.org/wiki/Recurrence_relation

    """
    fwd = [shifts[0]]
    for i in range(1, len(shifts)):
        temp = 0
        for j in range(i + 1):
            temp += special.binom(i, j) * (-1)**j * shifts[i-j]
        fwd.append(temp)
    return fwd


class ObjectPainter:
    """"""
    def __init__(self, cr: 'Cairo.Context', resolution: 'tuple'):
        self._cr = cr
        self._res = resolution

    def resolution_transform(self, point: 'tuple') -> 'tuple':
        """Rescale points from normalized coordinate system to resolution.

        Notes
        -----
            10 is added to both transformed coordinates to account for
            the clip region.

        """
        x_w, y_w = point
        x_vp = (x_w + 1) / (2) * self._res[0] + 10
        y_vp = (1 - (y_w + 1) / (2)) * self._res[1] + 10
        return (x_vp, y_vp)

    def paint_point(self, point: 'Point'):
        """Draw point."""
        p = self.resolution_transform(point.cached_points[0])
        self._cr.move_to(*p)
        self._cr.line_to(*p)
        self._cr.stroke()

    def paint_line(self, line: 'Line'):
        """Draw line."""
        p0, p1 = list(map(self.resolution_transform, line.cached_points))
        self._cr.move_to(*p0)
        self._cr.line_to(*p1)
        self._cr.stroke()

    def paint_polymesh(self, mesh: 'Mesh'):
        """Draw vertex-face mesh."""
        points = list(map(self.resolution_transform, mesh.cached_points))
        for face in mesh.cached_faces:
            self._cr.move_to(*points[face[0]])
            for i in face[1:]:
                self._cr.line_to(*points[i])
            self._cr.line_to(*points[face[0]])
            self._cr.stroke()

    def paint_curve(self, curve: 'Curve'):
        """Draw curve."""
        def generate_segment(n: 'int', basis: 'ndarray', geometry: 'ndarray'):
            """Generate cubic spline segment from geometry matrix and
            polynomial basis using forward differences.

            Notes
            -----
                The parametric curves for x and y are generated by dotting the
                change of basis matrix `basis` with the coordinates of a given
                n-degree polynomial `geometry`.

                The forward differences are calculated using the recurrence
                relation:

                    D^(k)[fn+1] = D^(k)[fn] + D^(k+1)[fn]

                Lines that would cause the painter to leave the screen are
                clipped aggainst window borders. For that, it's assumed
                `clip_line` always lands on the 'one intersection' case and
                that the new point at intersection is the first of the returned
                list.

            """
            def out(x, y):
                """Test if given point is outside the window."""
                return x > 1 or x < -1 or y > 1 or y < - 1

            delta = 1 / n
            spline_x = basis@np.array([p[0] for p in geometry])
            spline_y = basis@np.array([p[1] for p in geometry])
            degree = len(spline_x) - 1

            shifts_spline_x = [spline_x.dot(np.array(
                [(i*delta)**n for n in range(3, -1, -1)])) for i in range(degree+1)]
            shifts_spline_y = [spline_y.dot(np.array(
                [(i*delta)**n for n in range(3, -1, -1)])) for i in range(degree+1)]
            fwd_x = init_forward_differences(shifts_spline_x)
            fwd_y = init_forward_differences(shifts_spline_y)

            points = []
            prev_out = True
            prev_point = None
            for i in range(n+1):
                if out(fwd_x[0], fwd_y[0]):
                    if not prev_out:  # Leaving the window
                        self._cr.line_to(*self.resolution_transform(clip_line(
                            [prev_point, (fwd_x[0], fwd_y[0])])[0]))
                        self._cr.stroke()
                        prev_out = True
                else:
                    if prev_out:  # Entering the window
                        if prev_point is None:
                            self._cr.move_to(*self.resolution_transform((fwd_x[0], fwd_y[0])))
                        else:
                            point_at_window = clip_line([(fwd_x[0], fwd_y[0]), prev_point])[0]
                            self._cr.move_to(*self.resolution_transform(point_at_window))
                            self._cr.line_to(*self.resolution_transform((fwd_x[0], fwd_y[0])))
                        prev_out = False
                    else:  # Already inside window
                        self._cr.line_to(*self.resolution_transform((fwd_x[0], fwd_y[0])))

                prev_point = (fwd_x[0], fwd_y[0])

                for j in range(degree):
                    fwd_x[j] += fwd_x[j+1]
                    fwd_y[j] += fwd_y[j+1]
            self._cr.stroke()

        cp = curve.cached_points
        if curve.ctype is CurveType.BEZIER:
            generate_segment(100, curve.ctype, cp[:4])
            for i in range((len(cp) - 4) // 2):
                geometry = [cp[2*i+3], cp[2*i+2],
                            cp[2*i+4], cp[2*i+5]]
                generate_segment(100, curve.ctype, geometry)
        else:
            for i in range(len(cp) - 3):
                generate_segment(100, curve.ctype, cp[i:i+4])
